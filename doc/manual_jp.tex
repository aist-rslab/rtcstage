\documentclass[a4paper,10pt]{article}

\usepackage{CJKutf8}
% \usepackage[UKenglish]{babel}
\usepackage[overlap, CJK]{ruby}
\usepackage{CJKulem}

\renewcommand{\rubysep}{-0.2ex}
\newenvironment{Japanese}{%
  \CJKfamily{min}%
  \CJKtilde
  \CJKnospace}{}

\usepackage{listings}
\usepackage{a4wide}
\usepackage{tabularx}
\usepackage{booktabs}

\lstloadlanguages{Bash}
\lstset{basicstyle=\small\ttfamily, escapeinside={(*@}{@*)},
showstringspaces=false, breaklines=true, breakatwhitespace=true,
tabsize=4, language=Bash, numberfirstline=true,
commentstyle=\itshape\color{CommentGreen},
stringstyle=\color{DataTypeBlue}}
\newcommand{\ilcode}[1]{\lstinline|#1|}

\title{RTC:Stage}
\author{Geoffrey Biggs (ジェフ・ビグズ)\\
geoffrey.biggs@aist.go.jp}

\begin{document}
\begin{CJK}{UTF8}{}
\begin{Japanese}

\maketitle

\section{はじめに}
\label{sec:intro}

RTC:StageはOpenRTM-aist用のRTコンポーネントです。
Stage\footnote{http://playerstage.sourceforge.net/}というシミュレータの
仮想空間へのアクセスを提供します。仮想空間のモデルは他のコンポーネントで
操作することが可能で、仮想空間内のデータを他のコンポーネントで使うことも可能です。
大きな仮想空間でもコンポーネントを使いやすい小さいサイズにフィルタリングする
機能も提供しています。
また、コンポーネントの生成や追加によりシミュレータ側で新しいモデルを作成す
る事が可能なプラグイン機能もサポートしてます。

本コンポーネントの特徴の一つは、コンポーネントのポートが自動的に仮想空間に対応づけられることです。
仮想空間に複数のロボットがあっても、コンポーネント側で別々のポートにより操作することが可能です。
また、ポートの名前も設定することが可能です。
セクション~\ref{sec1:naming}を参照してください。

このソフトウェアは産業技術総合研究所で開発されています。承認番号はH22PRO-1194です。
開発は新エネルギー・産業技術総合開発機構（Project for Strategic Development of Advanced
Robotics Elemental Technologies）に支えられました。このソフトウェアは
Eclipse Public License -v 1.0 (EPL)でライセンスされています。LICENSE.txtを
参照してください。

\section{条件}
\label{sec:requirements}

RTC:StageはOpenRTM-aistのC++版と最新のStage（Git
リポジトリー\footnote{http://github.com/rtv/Stage}から）が必要です。
Stageの最新リリースバージョンにはRTC:Stageが必要なAPIはまだ入っていません。

RTC:StageはCMake\footnote{http://www.cmake.org/}を使います。Cmake
2.6以上が必要です。

プラグインを使う場合はGNUの
libtool\footnote{http://www.gnu.org/software/libtool/}にあるlibltdlが
必要です。

Stage自体はWindowsでは使えないので、コンポーネントはLinuxもしくは、MacOS Xが必要です。

\section{インストール}
\label{sec:installation}

パッケージを使う場合はそのパッケージの説明に従ってインストールを行ってください。

ソースからインストールを行う場合は以下の手順で進めてください。

\begin{enumerate}
  \item ソースをダウンロードして解凍してください。

  \verb|tar -xvzf rtcstage-1.0.0.tar.gz|
  \item 解凍されたフォルダに入ってください。

  \verb|cd rtcstage-1.0.0|
  \item ``build''フォルダを作ってください。

  \verb|mkdir build|
  \item ``build''フォルダに入ってください。

  \verb|cd build|
  \item CMakeを実行してください。

  \verb|cmake ../|
  \item エラーが出なければ、makeを実行してください。

  \verb|make|
  \item make
  installでコンポーネントをインストールしてください。選択されたインストール
  場所への権限があるかを事前に確認してください。

  \verb|make install|
  \item
  インストールする場所はccmakeを実行して\verb|CMAKE_INSTALL_PREFIX|を
  設定することにより変更することが可能です。

  \verb|ccmake ../|
\end{enumerate}

ここまでで、コンポーネントを使えるようになりました。コンフィグレーションは次のセクションを
参照してください。

RTC:Stageは\verb|rtcstage_standalone|の実行（\verb|${prefix}/bin|に
インストールされてます）によりスタンドアローンモードで実行 することができます。
あるいは、\verb|librtcstage.so|を初期化関数の\verb|rtcstage_init|を利用して、
マネージャにロードすることも可能です。このライブラリは\verb|${prefix}/lib|
または\verb|${prefix}/lib64|にインストールされてます。


\section{コンフィグレーション}
\label{sec:configuration}

RTC:Stageは仮想空間と一致するポートをダイナミックに作るため特別な起動方法を
使います。このため、コンフィグレーションはRTSystemEditorやrtshellによってではなく、
rtc.confなどのコンフィグレーションファイルでパラメータを設定する必要があります。

コンポーネントのコンフィグレーションを設定するために、以下のようなファイルを作ってください。

\begin{lstlisting}[frame=tb, language=bash]
configuration.active_config: simple

conf.simple.world_file: /usr/local/share/stage/worlds/simple.world
conf.simple.gui_x: 640
conf.simple.gui_y: 480
conf.simple.limit_models:
\end{lstlisting}

一つのファイルで複数のコンフィグレーションセットを設定することができます。
上記ファイルの最初の行では、起動時のコンフィグレーションセットを指定してます。
ファイルに正しい名前をつけ（例：``stage.conf''）、\verb|rtc.conf|に以下の行を追加してください。

\begin{lstlisting}[frame=tb, language=bash]
Simulation.RTC_Stage.config_file: stage.conf
\end{lstlisting}

本コンポーネントで使えるコンフィグレーションパラメータについては、テーブル~\ref{tab:config_params}を参照
してください。

\begin{table}[t]
  \centering
  \begin{tabularx}{\columnwidth}{lX}
    \toprule
    パラメータ & 意味 \\
    \midrule
    world\_file & ロードするワールドファイルです。Stageの説明書を参照してください。Stageをインストールする時、サンプルワールドファイルがインストールされます。 \\
    gui\_x & シミュレータのウィンドウの幅です。 \\
    gui\_y & シミュレータのウィンドウの高さです。 \\
    limit\_models & モデルのフィルターです。セクション~\ref{sec1:filtering-models}を参照してください。 \\
    plugins & プロキシープラグインです。セクション~\ref{sec1:proxy-plugins}を参照してください。 \\
    \bottomrule
  \end{tabularx}
  \caption{コンフィグレーションパラメータ。}
  \label{tab:config_params}
\end{table}

\section{ポート}
\label{sec:port}

コンポーネントは\emph{初期化される時}に提供するポートをダイナミックに作ります。

\subsection{ポート名}
\label{sec1:naming}

ポート名は仮想空間を反映し、それらがどのモデルにアクセスを提供するかを示します。例えば、
仮想空間に「r0」という名前のロボットがあれば、そのロボットの速度コントロール、
オドメトリ出力、幾何学サービスなどへのアクセスを提供するポートが作られます。これらのポートはすべて
接頭辞に「r0\_」が付きます。ポートがどのように作成されるかの例については、
テーブル~\ref{tab:port_naming}を参照してください。特殊文事（「.」と「:」）が「\_」
に取り替えられることに注意してください。

\begin{table}[t]
  \centering
  \begin{tabular}{lll}
    \toprule
    モデル種類 & モデル名 & ポート名 \\
    \midrule
    Robot & r0 & r0\_vel\_control \\
    Laser & r0.laser:0 & r0\_laser\_0\_ranges \\
    Camera & r0.camera:1 & r0\_camera\_1\_image \\
    \bottomrule
  \end{tabular}
  \caption{ポート名の例。}
  \label{tab:port_naming}
\end{table}

\section{モデルプロキシー}
\label{sec:model-proxies}

RTC:Stageコンポーネントは、仮想空間に含まれているモデルへのアクセスを提供する
ためにモデルプロキシーを使用します。仮想空間のモデルのインスタンスはそれぞれコンポーネント
のモデルプロキシーのインスタンスに直接対応付けられます。いくつかのプロキシーはコンポーネントに
よって提供されています。これらはStageでサポートされている最も人気なモデルをカバーします。
これらはテーブル~\ref{tab:proxies}で述べられています。

プロキシーが提供されていないStageのモデルを使用したい場合、プラグインプロキシーを
作ることが可能です。詳細についてはセクション~\ref{sec1:proxy-plugins}を参照してください。

\begin{table}[t]
  \centering
  \begin{tabularx}{\columnwidth}{lllX}
    \toprule
    プロキシー & ポート & データ形 & ポートの意味 \\
    \midrule
    Actuator & vel\_control & TimedDouble & アクチュエータの速度制御。 \\
     & pos\_control & TimedDouble & アクチュエータの位置制御。 \\
     & state & ActArrayState & アクチュエータの現在の状態。 \\
     & current\_vel & TimedDouble & アクチュエータの現在の速度。 \\
     & svc & GetGeometry2D & アクチュエータの位置とサイズの取得。 \\
    Camera & control & TimedPoint2D & パンとティルトに対するコントロール。 \\
     & image & CameraImage & カメラからのイメージ（RGBA）。 \\
     & depth & CameraImage & カメラからの深さイメージ（8ビット）。 \\
     & svc & GetGeometry2D & カメラの位置とサイズの取得。 \\
    Fiducial & fiducials & Fiducials & 現在検知されたfiducialのリスト。 \\
     & svc & GetGeometry2D & Fiducialセンサーの位置とサイズの取得。 \\
    Gripper & state & GripperState & グリッパーの状態。 \\
     & svc & GetGeometry2D & グリッパーの位置とサイズの取得。 \\
     & & GripperControl & グリッパーの開閉。 \\
    Laser & ranges & RangeData & レンジデータ。 \\
     & intensities & IntensityData & インテンシティーデータ \\
     & svc & GetGeometry2D & レーザの位置とサイズの取得。 \\
    Position & vel\_control & TimedVelocity2D & ロボットの速度制御。 \\
     & pose\_control & TimedPose2D & ロボットの位置制御。 \\
     & current\_vel & TimedVelocity2D & ロボットの現在の速度。 \\
     & odometry & TimedPose2D & ロボットの現在のオドメトリー。 \\
     & svc & GetGeometry2D & ロボットの位置とサイズの取得。 \\
     & & SetOdometry2D & ロボットの現在のオドメトリーの設定。 \\
    \bottomrule
  \end{tabularx}
  \caption{RTC:Stageのプロキシー。}
  \label{tab:proxies}
\end{table}

\subsection{モデルフィルタ}
\label{sec1:filtering-models}

多くのモデルのシミュレーションを行う場合、プロキシーされたモデル、そしてコンポーネントによって提供
されるポートの数は収集不可能になるかもしれません。これを回避するために、ユーザはコンポーネントの
コンフィグレーションでモデル名フィルタを指定することができます。コンポーネントはフィルタに
含まれたモデルのプロキシーだけを作成します。

フィルタのフォーマットはコンマによって区切られたストリングのリストです。それぞれのストリングが
フィルタです。モデル名は、プロキシーが作成されるために少なくとも一つのフィルタと一致する必要
があります。ワイルドカード（「*」）はフレキシブルなフィルタを指定するために使用することができます。
フィルタフォーマットをテーブル~\ref{tab:filters}に示します。

\begin{table}[t]
  \centering
  \begin{tabularx}{0.6\columnwidth}{lX}
    \toprule
     フィルター & 影響 \\
    \midrule
    \verb|filter| & モデル名が全て一致。 \\
    \verb|*filter| & モデル名の最後のストリングが一致。 \\
    \verb|filter*| & モデル名の先頭のストリングが一致。 \\
    \verb|*filter*| & モデル名の一部のストリングが一致。 \\
    \verb|filter1*,filter2*| & 二つのフィルター。 \\
    \bottomrule
  \end{tabularx}
  \caption{フィルタフォーマットの例。}
  \label{tab:filters}
\end{table}

例えば、２台のロボット、「r0」及び「r1」を含んでいるシミュレーションを考慮してください。
「r0」にはレーザーセンサー及びカメラがあります。「r1」には二つのレーザーセンサーがあります。
シミュレートされたコンポーネントは、以下のモデルにプロキシーを提供します。

\begin{itemize}
  \item r0
  \item r0.camera:0
  \item r0.laser:0
  \item r1
  \item r1.laser:0
  \item r1.laser:1
\end{itemize}

フィルタなしでは、これは多くのポートを備えたRTC:Stageのインスタンスを生産します。ユーザが単に
利用可能なモデルの一部だけに興味を持っていれば、適切なフィルタによってプロキシーの数を制限することが
できます。テーブル~\ref{tab:filtered_proxies}は、異なるフィルタストリングでプロキシー
されたモデルの例を示します。

\begin{table}[t]
  \centering
  \begin{tabular}{ll}
    \toprule
    フィルタ & 作成されたプロキシー \\
    \midrule
    \verb|r0| & r0 \\
    \verb|r0*| & r0, r0.camera:0, r0.laser:0 \\
    \verb|*camera:0| & r0.camera:0 \\
    \verb|*:0| & r0.camera:0, r0.laser:0, r1.laser:0 \\
    \verb|*laser*| & r0.laser:0, r1.laser:0, r1.laser:1 \\
    \verb|r0.laser*,r1.laser*| & r0.laser:0, r1.laser:0, r1.laser:1 \\
    \verb|r1,*laser:0| & r0.laser:0, r1, r1.laser:0, r1.laser:1 \\
    \bottomrule
  \end{tabular}
  \caption{いろいろなフィルタの結果で作成されたプロキシー。}
  \label{tab:filtered_proxies}
\end{table}

\subsection{プラグインプロキシー}
\label{sec1:proxy-plugins}

Stageシミュレータはモデルプラグインを書くことをサポートします。これらは、新しいデバイスタイプが
Stage自体を修正せずに、容易にシミュレートすることを可能にするため、シミュレーションでの機能の追加
を提供します。多くのロボット開発者がこの方法で新しい装備を実装したいと思うかもしれません。
そのようなモデルはRTC:Stageではデフォルトではサポートされません。サポートをするために、モデル
プラグインに合うプロキシープラグインを作成しなければなりません。プロキシープラグインも
 \verb|ModelPosition| モデルのようなStageに組み込まれたモデルのために作成することができます。また、
RTC:Stageに含まれたプロキシーを無視する、新しいプロキシーも作成することができます。

プロキシープラグインは\verb|ModelProxy|インターフィースのインプリメンテーションを提供します。
それは、このインターフェースの抽象メソッドを実装しなければならず、RTC:Stageコンポーネントに
ポートを関連付けるために重要です。されに、それはこれらのポートとシミュレーションの間のデータを
やり取りするために重要です。

されに、プロキシープラグインは2つのシンボルを書き出す必要があります：
\begin{itemize}
  \item \verb|GetProxyType| - プラグインのモデル種類を返す。
  \item \verb|ProxyFactory| - プラグインのインスタンスを作成する.
\end{itemize}

プロキシープラグインをコンパイルするには\verb|BUILD_PROXY_PLUGIN|というCMake用のマクロを
使ってください。\verb|RTCStagePlugin|というCMakeファイルで提供されています。

RTC:Stageにはプラグインのサンプルがあります。\verb|${prefix}/share/rtcstage/examples/|に
インストールされます。プロキシープラグインの作成についての詳細については、これらのサンプルを参照
してください。一般に、サンプルをコピーしソースを新しいモデルに合わせる用に修正する方が開発が早い
でしょう。

\subsection{プラグインの例}
\label{sec1:example-plugins}

RTC:Stageには二つのプラグインのサンプルがあります。\verb|${prefix}/share/rtcstage/examples/|
にインストールされます。\verb|${prefix}|はRTC:Stageがインストールされたフォルダです。
プラグインはCMakeでコンパイルすることができます。

\begin{enumerate}
  \item \verb|cd ${prefix}/share/rtc\_stage/examples/blobfinder/|
  \item \verb|mkdir build|
  \item \verb|cd build|
  \item \verb|cmake ../|
  \item \verb|make|
\end{enumerate}

\subsubsection{Blobfinderプロキシー}
\label{sec2:blobfinder-proxy}

このサンプルプラグインはStageのblobfinderセンサーモデルにプロキシーを提供します。必要なデータ型を
提供するためにプラグインでユーザのIDLファイルを使用するサンプルを示してます。

\subsubsection{Positionプロキシー}
\label{sec2:position-proxy}

このプラグインはデフォルトの位置モデルプロキシーをカスタムプロキシーに取り替えて明示してます。
このプラグインによって提供されるプロキシーを読み込む事によって、デフォルトのpositionプロキシーは
コンポーネント中で無視されます。新しいプロキシーは異なるデータ型を使用するため、モデルに代替
インターフェースを提供します。

% \section{Changelog}

\end{Japanese}
\end{CJK}
\end{document}

